## 1. 변수 쪼개기
- 여러 용도로 쓰인 변수는 코드를 읽는 이에게 혼란을 주므로, 역할이 둘 이상인 변수가 있다면 쪼개야 한다.

### 절차
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
    - 이후의 대입이 항상 i = i + <무언가> 형태라면 수집 변수이므로 쪼개면 안 된다. 수집 변수는 총합 계산, 문자열 연결, 스트림에 쓰기, 컬렉션에 추가하기 등의 용도로 흔히 쓰인다.
2. 가능하면 이때 불변으로 선언한다.
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조(이 변수가 쓰인 곳)를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트한다.
6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.

## 2. 필드 이름 바꾸기
- 데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다.

### 절차
1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요 없다.
2. 레코드가 캡슐화되지 않았다면 우선 레코드를 캡슐화한다.
3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.
4. 테스트한다.
5. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 함수 선언 바꾸기로 변경한다.
6. 접근자들의 이름도 바꿔준다.

## 3. 파생 변수를 질의 함수로 바꾸기
- 가변 데이터는 수정한 값의 연쇄효과를 일으켜 원인을 찾기 어려운 문제를 야기해 유효 범위를 가능한 한 좁혀야 한다.
- 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거하면, 데이터의 의미를 더 분명히 드러내고 결과 변수에 변경된 값을 반영하지 않는 실수를 막아준다.
- 새로운 데이터 구조를 생성하는 변형 연산이라면 계산 코드로 대체할 수 있더라도 그대로 두는 것이 좋다.

### 절차
1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
   - 필요하면 변수 캡슐화하기를 적용하여 어서션이 들어갈 장소를 마련해준다.
4. 테스트한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트한다.
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.

## 4. 참조를 값으로 바꾸기
- 값 객체는 불변이므로 분산 시스템과 동시성 시스템에서 특히 유용하다.

### 절차
1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.
2. 각각의 세터를 하나씩 제거한다.
3. 이 값 객체의 필드들을 사용하는 동치성비교 메서드를 만든다.
   - 대부분의 언어는 이런 상황에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메서드를 제공한다. 동치성 비교 메서드를 오버라이드할 때는 보통 해시코드 생성 메서드도 함께 오버라이드해야 한다.

## 5. 값을 참조로 바꾸기

### 절차
1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다.(이미 있다면 생략)
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트한다.

## 느낀점 
- 동치성 비교 메서드를 오버라이드할 때는 보통 해시코드 생성 메서드도 오버라이드해야한다라는 부분을 읽으면서 코드 리뷰를 받을 때 왜 해시코드 메서드도 같이 구현해야 하는지에 대해 리뷰를 받은 적이 있었는데, 그때 찾아본 바로는 해시 컬렉션을 사용할 때의 동치성을 보장해주기 위해서였다. 
- 사실 객체 비교를 위해 관습적으로 @EqualsAndHashCode 애노테이션을 사용했었고 hashCode()의 필요성을 깊이 고민해 본 적이 없었는데 그때 경험을 통해 작은 부분이라도 왜 필요한지 이유를 알고 쓰는 것이 중요하다고 생각했다.
- 9.5 값을 참조로 바꾸기에서 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 저장소 개념이 나왔다. 각 엔티티를 표현하는 객체를 한 번만 생성하고 필요한 곳에서는 이 저장소로부터 얻어 쓰는 방식이 스프링의 빈과 애플리케이션 컨텍스트와 유사하다고 느꼈다.